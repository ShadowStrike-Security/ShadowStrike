/**
 * ============================================================================
 * ShadowStrike NGAV - ENTERPRISE WPP TRACING IMPLEMENTATION
 * ============================================================================
 *
 * @file Trace.c
 * @brief Enterprise-grade WPP tracing implementation for kernel EDR.
 *
 * Provides CrowdStrike Falcon-level tracing infrastructure with:
 * - Full WPP (Windows Software Trace Preprocessor) integration
 * - Runtime trace level and flag management
 * - Rate limiting to prevent trace flooding
 * - Correlation ID generation for request tracking
 * - Structured trace contexts for complex operations
 * - Statistics tracking and monitoring
 * - IRQL-safe operations throughout
 *
 * Architecture:
 * - Global trace configuration with atomic updates
 * - Lock-free statistics using InterlockedXxx operations
 * - Monotonic sequence numbers for trace ordering
 * - Session GUIDs for trace session correlation
 * - Per-second rate limiting with automatic reset
 *
 * Performance Characteristics:
 * - O(1) trace level/flag checking
 * - Lock-free correlation ID generation
 * - Minimal overhead when tracing disabled
 * - Rate limiting prevents performance degradation
 *
 * Security Properties:
 * - No sensitive data in trace messages by default
 * - Correlation IDs enable forensic analysis
 * - Audit trail for security events
 * - Tamper detection via sequence numbers
 *
 * MITRE ATT&CK Coverage:
 * - T1070: Indicator Removal (audit trail preservation)
 * - T1562: Impair Defenses (tamper detection logging)
 * - T1027: Obfuscated Files (deobfuscation tracing)
 *
 * @author ShadowStrike Security Team
 * @version 2.0.0 (Enterprise Edition)
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 * ============================================================================
 */

#include <ntddk.h>
#include <wdm.h>
#include <ntstrsafe.h>
#include "Trace.h"
#include "WppConfig.h"

//
// WPP Tracing - Include TMH file generated by WPP preprocessor
// This must come after the Trace.h include
//
#if defined(WPP_TRACING)
#include "Trace.tmh"
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, WppTraceInitialize)
#pragma alloc_text(PAGE, WppTraceShutdown)
#endif

// ============================================================================
// INTERNAL CONSTANTS
// ============================================================================

#define TRACE_SIGNATURE             'ECRT'  // 'TRCE' reversed
#define TRACE_MAX_RATE_LIMIT        1000000 // 1M traces/second max
#define TRACE_DEFAULT_RATE_LIMIT    100000  // 100K traces/second default
#define TRACE_RATE_RESET_INTERVAL   10000000LL  // 1 second in 100ns units

#define TRACE_CORRELATION_EPOCH     0x0001000000000000ULL  // Epoch for correlation IDs
#define TRACE_SEQUENCE_MASK         0x0000FFFFFFFFFFFFULL  // 48-bit sequence

// ============================================================================
// GLOBAL STATE
// ============================================================================

/**
 * @brief Global trace configuration instance.
 */
static WPP_TRACE_CONFIG g_TraceConfig = {0};

/**
 * @brief Initialization state flag.
 */
static volatile LONG g_TraceInitialized = 0;

/**
 * @brief Driver object reference for WPP.
 */
static PDRIVER_OBJECT g_DriverObject = NULL;

/**
 * @brief Correlation ID counter (atomically incremented).
 */
static volatile LONG64 g_CorrelationCounter = 0;

/**
 * @brief Boot time for timestamp calculations.
 */
static LARGE_INTEGER g_BootTime = {0};

/**
 * @brief Performance counter frequency.
 */
static LARGE_INTEGER g_PerfFrequency = {0};

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

static VOID
TracepResetRateLimit(
    VOID
    );

static BOOLEAN
TracepCheckRateLimit(
    VOID
    );

static VOID
TracepGenerateSessionGuid(
    _Out_ PGUID SessionGuid
    );

static UINT64
TracepGetTimestamp(
    VOID
    );

// ============================================================================
// INITIALIZATION AND SHUTDOWN
// ============================================================================

/**
 * @brief Initialize WPP tracing subsystem.
 *
 * Must be called during DriverEntry before any trace calls.
 * Sets up WPP, initializes configuration, and generates session GUID.
 *
 * @param DriverObject Driver object pointer.
 * @param RegistryPath Registry path for driver.
 *
 * @return STATUS_SUCCESS on success.
 *
 * @irql PASSIVE_LEVEL
 */
_Use_decl_annotations_
NTSTATUS
WppTraceInitialize(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;

    PAGED_CODE();

    //
    // Validate parameters
    //
    if (DriverObject == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check if already initialized
    //
    if (InterlockedCompareExchange(&g_TraceInitialized, 1, 0) != 0) {
        return STATUS_ALREADY_REGISTERED;
    }

    //
    // Store driver object reference
    //
    g_DriverObject = DriverObject;

    //
    // Initialize WPP Tracing
    //
#if defined(WPP_TRACING)
    WPP_INIT_TRACING(DriverObject, RegistryPath);
#else
    UNREFERENCED_PARAMETER(RegistryPath);
#endif

    //
    // Initialize global configuration
    //
    RtlZeroMemory(&g_TraceConfig, sizeof(WPP_TRACE_CONFIG));

    g_TraceConfig.TracingEnabled = TRUE;
    g_TraceConfig.DebugTracingEnabled = FALSE;
    g_TraceConfig.PerfTracingEnabled = FALSE;
    g_TraceConfig.SecurityTracingEnabled = TRUE;

    g_TraceConfig.MinimumLevel = TRACE_LEVEL_INFORMATION;
    g_TraceConfig.MaximumLevel = TRACE_LEVEL_VERBOSE;

    g_TraceConfig.EnabledFlags = TRACE_FLAG_ALL;
    g_TraceConfig.DisabledFlags = 0;

    g_TraceConfig.MaxTracesPerSecond = TRACE_DEFAULT_RATE_LIMIT;
    g_TraceConfig.CurrentSecondTraces = 0;

    //
    // Initialize rate limit timer
    //
    KeQuerySystemTime(&g_TraceConfig.CurrentSecondStart);

    //
    // Initialize statistics
    //
    g_TraceConfig.TotalTraces = 0;
    g_TraceConfig.DroppedTraces = 0;
    g_TraceConfig.ErrorCount = 0;
    g_TraceConfig.SequenceNumber = 0;

    //
    // Generate session GUID
    //
    TracepGenerateSessionGuid(&g_TraceConfig.SessionGuid);

    //
    // Get boot time for timestamp calculations
    //
    KeQuerySystemTime(&SystemTime);
    ExSystemTimeToLocalTime(&SystemTime, &LocalTime);
    g_BootTime = LocalTime;

    //
    // Get performance counter frequency
    //
    KeQueryPerformanceCounter(&g_PerfFrequency);

    //
    // Initialize correlation counter with timestamp-based seed
    //
    g_CorrelationCounter = (LONG64)(SystemTime.QuadPart & TRACE_SEQUENCE_MASK);

    //
    // Log initialization
    //
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "[ShadowStrike/Trace] WPP Tracing initialized. Session: {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
        g_TraceConfig.SessionGuid.Data1,
        g_TraceConfig.SessionGuid.Data2,
        g_TraceConfig.SessionGuid.Data3,
        g_TraceConfig.SessionGuid.Data4[0],
        g_TraceConfig.SessionGuid.Data4[1],
        g_TraceConfig.SessionGuid.Data4[2],
        g_TraceConfig.SessionGuid.Data4[3],
        g_TraceConfig.SessionGuid.Data4[4],
        g_TraceConfig.SessionGuid.Data4[5],
        g_TraceConfig.SessionGuid.Data4[6],
        g_TraceConfig.SessionGuid.Data4[7]
    );

    return STATUS_SUCCESS;
}

/**
 * @brief Shutdown WPP tracing subsystem.
 *
 * Must be called during driver unload. Flushes pending traces
 * and releases WPP resources.
 *
 * @param DriverObject Driver object pointer.
 *
 * @irql PASSIVE_LEVEL
 */
_Use_decl_annotations_
VOID
WppTraceShutdown(
    PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();

    if (DriverObject == NULL) {
        return;
    }

    //
    // Check if initialized
    //
    if (InterlockedCompareExchange(&g_TraceInitialized, 0, 1) != 1) {
        return;
    }

    //
    // Log final statistics before shutdown
    //
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "[ShadowStrike/Trace] Shutting down. Total: %lld, Dropped: %lld, Errors: %lld\n",
        g_TraceConfig.TotalTraces,
        g_TraceConfig.DroppedTraces,
        g_TraceConfig.ErrorCount
    );

    //
    // Disable tracing
    //
    g_TraceConfig.TracingEnabled = FALSE;

    //
    // Cleanup WPP Tracing
    //
#if defined(WPP_TRACING)
    WPP_CLEANUP(DriverObject);
#else
    UNREFERENCED_PARAMETER(DriverObject);
#endif

    //
    // Clear global state
    //
    g_DriverObject = NULL;
    RtlZeroMemory(&g_TraceConfig, sizeof(WPP_TRACE_CONFIG));
}

/**
 * @brief Check if tracing is initialized and enabled.
 *
 * Fast inline check for use in trace macros to avoid overhead
 * when tracing is disabled.
 *
 * @return TRUE if tracing is ready.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
BOOLEAN
WppTraceIsEnabled(
    VOID
    )
{
    return (g_TraceInitialized != 0) && g_TraceConfig.TracingEnabled;
}

// ============================================================================
// RUNTIME CONFIGURATION
// ============================================================================

/**
 * @brief Set minimum trace level.
 *
 * Traces below this level will be suppressed.
 *
 * @param Level Minimum level to trace (TRACE_LEVEL_*).
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
VOID
WppSetMinimumLevel(
    UCHAR Level
    )
{
    if (Level > TRACE_LEVEL_RESERVED) {
        Level = TRACE_LEVEL_RESERVED;
    }

    g_TraceConfig.MinimumLevel = Level;

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_TRACE_LEVEL,
        "[ShadowStrike/Trace] Minimum level set to %u\n",
        Level
    );
}

/**
 * @brief Get current minimum trace level.
 *
 * @return Current minimum level.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
UCHAR
WppGetMinimumLevel(
    VOID
    )
{
    return g_TraceConfig.MinimumLevel;
}

/**
 * @brief Enable/disable specific trace flags.
 *
 * @param Flags Flags to modify (TRACE_FLAG_*).
 * @param Enable TRUE to enable, FALSE to disable.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
VOID
WppSetTraceFlags(
    ULONG Flags,
    BOOLEAN Enable
    )
{
    if (Enable) {
        //
        // Enable flags (atomic OR)
        //
        InterlockedOr((volatile LONG*)&g_TraceConfig.EnabledFlags, (LONG)Flags);
        InterlockedAnd((volatile LONG*)&g_TraceConfig.DisabledFlags, ~(LONG)Flags);
    } else {
        //
        // Disable flags (atomic AND NOT)
        //
        InterlockedAnd((volatile LONG*)&g_TraceConfig.EnabledFlags, ~(LONG)Flags);
        InterlockedOr((volatile LONG*)&g_TraceConfig.DisabledFlags, (LONG)Flags);
    }

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_TRACE_LEVEL,
        "[ShadowStrike/Trace] Flags 0x%08X %s\n",
        Flags,
        Enable ? "enabled" : "disabled"
    );
}

/**
 * @brief Get currently enabled trace flags.
 *
 * @return Current enabled flags bitmask.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
ULONG
WppGetTraceFlags(
    VOID
    )
{
    return g_TraceConfig.EnabledFlags & ~g_TraceConfig.DisabledFlags;
}

/**
 * @brief Set trace rate limit.
 *
 * Limits the number of traces per second to prevent flooding
 * and performance degradation under high load.
 *
 * @param MaxTracesPerSecond Maximum traces per second (0 = unlimited).
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
VOID
WppSetRateLimit(
    ULONG MaxTracesPerSecond
    )
{
    if (MaxTracesPerSecond > TRACE_MAX_RATE_LIMIT) {
        MaxTracesPerSecond = TRACE_MAX_RATE_LIMIT;
    }

    g_TraceConfig.MaxTracesPerSecond = MaxTracesPerSecond;

    //
    // Reset current second counter
    //
    TracepResetRateLimit();

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_TRACE_LEVEL,
        "[ShadowStrike/Trace] Rate limit set to %u traces/second\n",
        MaxTracesPerSecond
    );
}

// ============================================================================
// CORRELATION API
// ============================================================================

/**
 * @brief Generate a new unique correlation ID.
 *
 * Correlation IDs enable tracking related events across multiple
 * trace messages. Uses atomic increment for uniqueness.
 *
 * @return New unique correlation ID.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
UINT64
WppGenerateCorrelationId(
    VOID
    )
{
    LONG64 Sequence;
    UINT64 CorrelationId;

    //
    // Atomically increment counter
    //
    Sequence = InterlockedIncrement64(&g_CorrelationCounter);

    //
    // Combine epoch with sequence for globally unique ID
    //
    CorrelationId = TRACE_CORRELATION_EPOCH | ((UINT64)Sequence & TRACE_SEQUENCE_MASK);

    return CorrelationId;
}

/**
 * @brief Create a trace context for structured logging.
 *
 * Trace contexts provide correlation, timing, and component
 * information for complex multi-step operations.
 *
 * @param Context Receives initialized context.
 * @param ComponentId Source component identifier.
 * @param ParentCorrelationId Parent correlation ID (0 for root operation).
 *
 * @return STATUS_SUCCESS on success.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
NTSTATUS
WppCreateTraceContext(
    PWPP_TRACE_CONTEXT Context,
    WPP_COMPONENT_ID ComponentId,
    UINT64 ParentCorrelationId
    )
{
    LARGE_INTEGER CurrentTime;

    if (Context == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (ComponentId >= WppComponent_Max) {
        ComponentId = WppComponent_Unknown;
    }

    //
    // Initialize context
    //
    RtlZeroMemory(Context, sizeof(WPP_TRACE_CONTEXT));

    //
    // Generate new correlation ID
    //
    Context->CorrelationId = WppGenerateCorrelationId();
    Context->ParentCorrelationId = ParentCorrelationId;

    //
    // Capture process/thread context
    //
    Context->ProcessId = (UINT32)(ULONG_PTR)PsGetCurrentProcessId();
    Context->ThreadId = (UINT32)(ULONG_PTR)PsGetCurrentThreadId();

    //
    // Set component identification
    //
    Context->ComponentId = (UINT32)ComponentId;
    Context->SubComponentId = 0;

    //
    // Record start timestamp
    //
    KeQuerySystemTime(&CurrentTime);
    Context->StartTimestamp = (UINT64)CurrentTime.QuadPart;
    Context->EndTimestamp = 0;

    //
    // Clear custom data
    //
    Context->CustomData = NULL;
    Context->CustomDataSize = 0;

    return STATUS_SUCCESS;
}

/**
 * @brief Complete a trace context (record end time).
 *
 * Records the completion timestamp for duration calculation.
 *
 * @param Context Context to complete.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
VOID
WppCompleteTraceContext(
    PWPP_TRACE_CONTEXT Context
    )
{
    LARGE_INTEGER CurrentTime;

    if (Context == NULL) {
        return;
    }

    //
    // Record end timestamp
    //
    KeQuerySystemTime(&CurrentTime);
    Context->EndTimestamp = (UINT64)CurrentTime.QuadPart;
}

// ============================================================================
// STATISTICS API
// ============================================================================

/**
 * @brief Get trace statistics.
 *
 * Returns accumulated trace statistics since initialization
 * or last reset.
 *
 * @param TotalTraces Receives total trace count (optional).
 * @param DroppedTraces Receives dropped trace count (optional).
 * @param ErrorCount Receives error count (optional).
 *
 * @return STATUS_SUCCESS on success.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
NTSTATUS
WppGetStatistics(
    PUINT64 TotalTraces,
    PUINT64 DroppedTraces,
    PUINT64 ErrorCount
    )
{
    if (!g_TraceInitialized) {
        return STATUS_NOT_FOUND;
    }

    if (TotalTraces != NULL) {
        *TotalTraces = (UINT64)g_TraceConfig.TotalTraces;
    }

    if (DroppedTraces != NULL) {
        *DroppedTraces = (UINT64)g_TraceConfig.DroppedTraces;
    }

    if (ErrorCount != NULL) {
        *ErrorCount = (UINT64)g_TraceConfig.ErrorCount;
    }

    return STATUS_SUCCESS;
}

/**
 * @brief Reset trace statistics.
 *
 * Clears all accumulated statistics counters.
 *
 * @irql <= DISPATCH_LEVEL
 */
_Use_decl_annotations_
VOID
WppResetStatistics(
    VOID
    )
{
    if (!g_TraceInitialized) {
        return;
    }

    InterlockedExchange64(&g_TraceConfig.TotalTraces, 0);
    InterlockedExchange64(&g_TraceConfig.DroppedTraces, 0);
    InterlockedExchange64(&g_TraceConfig.ErrorCount, 0);
    InterlockedExchange64(&g_TraceConfig.SequenceNumber, 0);

    TracepResetRateLimit();

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_TRACE_LEVEL,
        "[ShadowStrike/Trace] Statistics reset\n"
    );
}

// ============================================================================
// EXTENDED TRACING API
// ============================================================================

/**
 * @brief Check if specific trace level and flags are enabled.
 *
 * Used by trace macros to avoid formatting overhead when
 * tracing is disabled for a particular level/flag combination.
 *
 * @param Level Trace level to check.
 * @param Flags Trace flags to check.
 *
 * @return TRUE if tracing is enabled for this level/flags.
 *
 * @irql <= DISPATCH_LEVEL
 */
BOOLEAN
WppShouldTrace(
    _In_ UCHAR Level,
    _In_ ULONG Flags
    )
{
    ULONG EffectiveFlags;

    //
    // Quick check for global enable
    //
    if (!g_TraceInitialized || !g_TraceConfig.TracingEnabled) {
        return FALSE;
    }

    //
    // Check level
    //
    if (Level < g_TraceConfig.MinimumLevel) {
        return FALSE;
    }

    if (Level > g_TraceConfig.MaximumLevel) {
        return FALSE;
    }

    //
    // Check flags
    //
    EffectiveFlags = g_TraceConfig.EnabledFlags & ~g_TraceConfig.DisabledFlags;
    if ((Flags & EffectiveFlags) == 0) {
        return FALSE;
    }

    //
    // Check rate limit
    //
    if (!TracepCheckRateLimit()) {
        InterlockedIncrement64(&g_TraceConfig.DroppedTraces);
        return FALSE;
    }

    return TRUE;
}

/**
 * @brief Record a trace event (called by WPP infrastructure).
 *
 * Updates statistics and sequence number for each trace.
 *
 * @irql <= DISPATCH_LEVEL
 */
VOID
WppRecordTrace(
    VOID
    )
{
    InterlockedIncrement64(&g_TraceConfig.TotalTraces);
    InterlockedIncrement64(&g_TraceConfig.SequenceNumber);
}

/**
 * @brief Record a trace error.
 *
 * @irql <= DISPATCH_LEVEL
 */
VOID
WppRecordError(
    VOID
    )
{
    InterlockedIncrement64(&g_TraceConfig.ErrorCount);
}

/**
 * @brief Get current sequence number.
 *
 * @return Current trace sequence number.
 *
 * @irql <= DISPATCH_LEVEL
 */
UINT64
WppGetSequenceNumber(
    VOID
    )
{
    return (UINT64)g_TraceConfig.SequenceNumber;
}

/**
 * @brief Get session GUID.
 *
 * @param SessionGuid Receives session GUID.
 *
 * @return STATUS_SUCCESS on success.
 *
 * @irql <= DISPATCH_LEVEL
 */
NTSTATUS
WppGetSessionGuid(
    _Out_ PGUID SessionGuid
    )
{
    if (SessionGuid == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!g_TraceInitialized) {
        return STATUS_NOT_FOUND;
    }

    RtlCopyMemory(SessionGuid, &g_TraceConfig.SessionGuid, sizeof(GUID));
    return STATUS_SUCCESS;
}

// ============================================================================
// CONDITIONAL TRACING HELPERS
// ============================================================================

/**
 * @brief Enable/disable debug tracing.
 *
 * @param Enable TRUE to enable debug traces.
 *
 * @irql <= DISPATCH_LEVEL
 */
VOID
WppSetDebugTracing(
    _In_ BOOLEAN Enable
    )
{
    g_TraceConfig.DebugTracingEnabled = Enable;

    if (Enable) {
        g_TraceConfig.MaximumLevel = TRACE_LEVEL_DEBUG;
    } else {
        g_TraceConfig.MaximumLevel = TRACE_LEVEL_VERBOSE;
    }
}

/**
 * @brief Enable/disable performance tracing.
 *
 * @param Enable TRUE to enable performance traces.
 *
 * @irql <= DISPATCH_LEVEL
 */
VOID
WppSetPerfTracing(
    _In_ BOOLEAN Enable
    )
{
    g_TraceConfig.PerfTracingEnabled = Enable;

    if (Enable) {
        WppSetTraceFlags(TRACE_FLAG_PERF, TRUE);
    } else {
        WppSetTraceFlags(TRACE_FLAG_PERF, FALSE);
    }
}

/**
 * @brief Enable/disable security event tracing.
 *
 * @param Enable TRUE to enable security traces.
 *
 * @irql <= DISPATCH_LEVEL
 */
VOID
WppSetSecurityTracing(
    _In_ BOOLEAN Enable
    )
{
    g_TraceConfig.SecurityTracingEnabled = Enable;

    if (Enable) {
        WppSetTraceFlags(TRACE_FLAG_SECURITY_ALL, TRUE);
    } else {
        WppSetTraceFlags(TRACE_FLAG_SECURITY_ALL, FALSE);
    }
}

/**
 * @brief Check if debug tracing is enabled.
 *
 * @return TRUE if debug tracing enabled.
 *
 * @irql <= DISPATCH_LEVEL
 */
BOOLEAN
WppIsDebugTracingEnabled(
    VOID
    )
{
    return g_TraceConfig.DebugTracingEnabled;
}

/**
 * @brief Check if performance tracing is enabled.
 *
 * @return TRUE if performance tracing enabled.
 *
 * @irql <= DISPATCH_LEVEL
 */
BOOLEAN
WppIsPerfTracingEnabled(
    VOID
    )
{
    return g_TraceConfig.PerfTracingEnabled;
}

/**
 * @brief Check if security tracing is enabled.
 *
 * @return TRUE if security tracing enabled.
 *
 * @irql <= DISPATCH_LEVEL
 */
BOOLEAN
WppIsSecurityTracingEnabled(
    VOID
    )
{
    return g_TraceConfig.SecurityTracingEnabled;
}

// ============================================================================
// FORMATTING HELPERS
// ============================================================================

/**
 * @brief Format NTSTATUS for trace output.
 *
 * @param Status NTSTATUS value.
 * @param Buffer Output buffer.
 * @param BufferSize Buffer size in characters.
 *
 * @return Number of characters written.
 *
 * @irql <= DISPATCH_LEVEL
 */
ULONG
WppFormatStatus(
    _In_ NTSTATUS Status,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    NTSTATUS FormatStatus;

    if (Buffer == NULL || BufferSize == 0) {
        return 0;
    }

    FormatStatus = RtlStringCchPrintfA(
        Buffer,
        BufferSize,
        "0x%08X",
        Status
    );

    if (!NT_SUCCESS(FormatStatus)) {
        Buffer[0] = '\0';
        return 0;
    }

    return (ULONG)strlen(Buffer);
}

/**
 * @brief Format GUID for trace output.
 *
 * @param Guid GUID to format.
 * @param Buffer Output buffer.
 * @param BufferSize Buffer size in characters.
 *
 * @return Number of characters written.
 *
 * @irql <= DISPATCH_LEVEL
 */
ULONG
WppFormatGuid(
    _In_ PGUID Guid,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    NTSTATUS Status;

    if (Guid == NULL || Buffer == NULL || BufferSize < 37) {
        return 0;
    }

    Status = RtlStringCchPrintfA(
        Buffer,
        BufferSize,
        "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        Guid->Data1,
        Guid->Data2,
        Guid->Data3,
        Guid->Data4[0],
        Guid->Data4[1],
        Guid->Data4[2],
        Guid->Data4[3],
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]
    );

    if (!NT_SUCCESS(Status)) {
        Buffer[0] = '\0';
        return 0;
    }

    return (ULONG)strlen(Buffer);
}

/**
 * @brief Format hex dump for trace output.
 *
 * @param Data Data to dump.
 * @param DataSize Size of data.
 * @param Buffer Output buffer.
 * @param BufferSize Buffer size in characters.
 *
 * @return Number of characters written.
 *
 * @irql <= DISPATCH_LEVEL
 */
ULONG
WppFormatHexDump(
    _In_reads_bytes_(DataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    PUCHAR Bytes;
    ULONG i;
    ULONG Offset = 0;
    ULONG MaxBytes;

    if (Data == NULL || Buffer == NULL || BufferSize < 3) {
        return 0;
    }

    Bytes = (PUCHAR)Data;

    //
    // Calculate maximum bytes we can format (2 hex chars + space per byte)
    //
    MaxBytes = (BufferSize - 1) / 3;
    if (DataSize > MaxBytes) {
        DataSize = MaxBytes;
    }

    for (i = 0; i < DataSize && Offset + 3 < BufferSize; i++) {
        NTSTATUS Status = RtlStringCchPrintfA(
            Buffer + Offset,
            BufferSize - Offset,
            "%02X ",
            Bytes[i]
        );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        Offset += 3;
    }

    //
    // Remove trailing space
    //
    if (Offset > 0) {
        Buffer[Offset - 1] = '\0';
        Offset--;
    } else {
        Buffer[0] = '\0';
    }

    return Offset;
}

/**
 * @brief Format timestamp for trace output.
 *
 * @param Timestamp 100ns timestamp.
 * @param Buffer Output buffer.
 * @param BufferSize Buffer size in characters.
 *
 * @return Number of characters written.
 *
 * @irql <= DISPATCH_LEVEL
 */
ULONG
WppFormatTimestamp(
    _In_ UINT64 Timestamp,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    LARGE_INTEGER Time;
    TIME_FIELDS TimeFields;
    NTSTATUS Status;

    if (Buffer == NULL || BufferSize < 24) {
        return 0;
    }

    Time.QuadPart = (LONGLONG)Timestamp;
    RtlTimeToTimeFields(&Time, &TimeFields);

    Status = RtlStringCchPrintfA(
        Buffer,
        BufferSize,
        "%04d-%02d-%02d %02d:%02d:%02d.%03d",
        TimeFields.Year,
        TimeFields.Month,
        TimeFields.Day,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second,
        TimeFields.Milliseconds
    );

    if (!NT_SUCCESS(Status)) {
        Buffer[0] = '\0';
        return 0;
    }

    return (ULONG)strlen(Buffer);
}

// ============================================================================
// INTERNAL HELPER FUNCTIONS
// ============================================================================

/**
 * @brief Reset rate limit counter.
 */
static VOID
TracepResetRateLimit(
    VOID
    )
{
    LARGE_INTEGER CurrentTime;

    KeQuerySystemTime(&CurrentTime);

    g_TraceConfig.CurrentSecondStart.QuadPart = CurrentTime.QuadPart;
    InterlockedExchange((LONG*)&g_TraceConfig.CurrentSecondTraces, 0);
}

/**
 * @brief Check and update rate limit.
 *
 * @return TRUE if trace is allowed, FALSE if rate limited.
 */
static BOOLEAN
TracepCheckRateLimit(
    VOID
    )
{
    LARGE_INTEGER CurrentTime;
    LONG CurrentCount;

    //
    // Unlimited if rate limit is 0
    //
    if (g_TraceConfig.MaxTracesPerSecond == 0) {
        return TRUE;
    }

    KeQuerySystemTime(&CurrentTime);

    //
    // Check if we've moved to a new second
    //
    if ((CurrentTime.QuadPart - g_TraceConfig.CurrentSecondStart.QuadPart) >= TRACE_RATE_RESET_INTERVAL) {
        TracepResetRateLimit();
    }

    //
    // Increment and check count
    //
    CurrentCount = InterlockedIncrement((LONG*)&g_TraceConfig.CurrentSecondTraces);

    if ((ULONG)CurrentCount > g_TraceConfig.MaxTracesPerSecond) {
        return FALSE;
    }

    return TRUE;
}

/**
 * @brief Generate a pseudo-random session GUID.
 *
 * Uses system time and performance counter for entropy.
 *
 * @param SessionGuid Receives generated GUID.
 */
static VOID
TracepGenerateSessionGuid(
    _Out_ PGUID SessionGuid
    )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER PerfCounter;
    PUCHAR GuidBytes;

    if (SessionGuid == NULL) {
        return;
    }

    //
    // Get entropy sources
    //
    KeQuerySystemTime(&SystemTime);
    PerfCounter = KeQueryPerformanceCounter(NULL);

    GuidBytes = (PUCHAR)SessionGuid;

    //
    // Mix entropy into GUID bytes
    //
    RtlCopyMemory(GuidBytes, &SystemTime.QuadPart, 8);
    RtlCopyMemory(GuidBytes + 8, &PerfCounter.QuadPart, 8);

    //
    // XOR with process ID for additional entropy
    //
    GuidBytes[0] ^= (UCHAR)((ULONG_PTR)PsGetCurrentProcessId() & 0xFF);
    GuidBytes[1] ^= (UCHAR)(((ULONG_PTR)PsGetCurrentProcessId() >> 8) & 0xFF);

    //
    // Set version 4 (random) and variant bits
    //
    SessionGuid->Data3 = (SessionGuid->Data3 & 0x0FFF) | 0x4000;  // Version 4
    SessionGuid->Data4[0] = (SessionGuid->Data4[0] & 0x3F) | 0x80;  // Variant 1
}

/**
 * @brief Get high-resolution timestamp.
 *
 * @return Current timestamp in 100ns units.
 */
static UINT64
TracepGetTimestamp(
    VOID
    )
{
    LARGE_INTEGER CurrentTime;

    KeQuerySystemTime(&CurrentTime);
    return (UINT64)CurrentTime.QuadPart;
}

// ============================================================================
// DIAGNOSTIC DUMP
// ============================================================================

/**
 * @brief Dump current trace configuration to debug output.
 *
 * @irql <= DISPATCH_LEVEL
 */
VOID
WppDumpConfiguration(
    VOID
    )
{
    if (!g_TraceInitialized) {
        DbgPrintEx(
            DPFLTR_IHVDRIVER_ID,
            DPFLTR_INFO_LEVEL,
            "[ShadowStrike/Trace] Not initialized\n"
        );
        return;
    }

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "============================================================\n"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "ShadowStrike WPP Trace Configuration Dump\n"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "============================================================\n"
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "Tracing Enabled: %s\n",
        g_TraceConfig.TracingEnabled ? "Yes" : "No"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "Debug Tracing: %s\n",
        g_TraceConfig.DebugTracingEnabled ? "Enabled" : "Disabled"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "Perf Tracing: %s\n",
        g_TraceConfig.PerfTracingEnabled ? "Enabled" : "Disabled"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "Security Tracing: %s\n",
        g_TraceConfig.SecurityTracingEnabled ? "Enabled" : "Disabled"
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "\nLevel Configuration:\n"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Minimum: %u (%s)\n",
        g_TraceConfig.MinimumLevel,
        WppGetLevelName(g_TraceConfig.MinimumLevel)
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Maximum: %u (%s)\n",
        g_TraceConfig.MaximumLevel,
        WppGetLevelName(g_TraceConfig.MaximumLevel)
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "\nFlags Configuration:\n"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Enabled: 0x%08X\n",
        g_TraceConfig.EnabledFlags
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Disabled: 0x%08X\n",
        g_TraceConfig.DisabledFlags
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Effective: 0x%08X\n",
        g_TraceConfig.EnabledFlags & ~g_TraceConfig.DisabledFlags
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "\nRate Limiting:\n"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Max/Second: %u\n",
        g_TraceConfig.MaxTracesPerSecond
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Current: %u\n",
        g_TraceConfig.CurrentSecondTraces
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "\nStatistics:\n"
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Total Traces: %lld\n",
        g_TraceConfig.TotalTraces
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Dropped: %lld\n",
        g_TraceConfig.DroppedTraces
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Errors: %lld\n",
        g_TraceConfig.ErrorCount
    );
    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "  Sequence: %lld\n",
        g_TraceConfig.SequenceNumber
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "\nSession GUID: {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
        g_TraceConfig.SessionGuid.Data1,
        g_TraceConfig.SessionGuid.Data2,
        g_TraceConfig.SessionGuid.Data3,
        g_TraceConfig.SessionGuid.Data4[0],
        g_TraceConfig.SessionGuid.Data4[1],
        g_TraceConfig.SessionGuid.Data4[2],
        g_TraceConfig.SessionGuid.Data4[3],
        g_TraceConfig.SessionGuid.Data4[4],
        g_TraceConfig.SessionGuid.Data4[5],
        g_TraceConfig.SessionGuid.Data4[6],
        g_TraceConfig.SessionGuid.Data4[7]
    );

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "============================================================\n"
    );
}
